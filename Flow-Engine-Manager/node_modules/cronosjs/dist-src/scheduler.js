const maxTimeout = Math.pow(2, 31) - 1;
const scheduledTasks = [];
let runningTimer = null;
function addTask(task) {
    if (task['_timestamp']) {
        const insertIndex = scheduledTasks.findIndex(t => (t['_timestamp'] || 0) < (task['_timestamp'] || 0));
        if (insertIndex >= 0)
            scheduledTasks.splice(insertIndex, 0, task);
        else
            scheduledTasks.push(task);
    }
}
function removeTask(task) {
    const removeIndex = scheduledTasks.indexOf(task);
    if (removeIndex >= 0)
        scheduledTasks.splice(removeIndex, 1);
    if (scheduledTasks.length === 0 && runningTimer) {
        clearTimeout(runningTimer);
        runningTimer = null;
    }
}
function runScheduledTasks() {
    if (runningTimer)
        clearTimeout(runningTimer);
    const now = Date.now();
    const removeIndex = scheduledTasks.findIndex(task => (task['_timestamp'] || 0) <= now);
    const tasksToRun = removeIndex >= 0 ? scheduledTasks.splice(removeIndex) : [];
    for (let task of tasksToRun) {
        task['_runTask']();
        if (task.isRunning) {
            task['_updateTimestamp']();
            addTask(task);
        }
    }
    const nextTask = scheduledTasks[scheduledTasks.length - 1];
    if (nextTask) {
        runningTimer = setTimeout(runScheduledTasks, Math.min((nextTask['_timestamp'] || 0) - Date.now(), maxTimeout));
    }
    else
        runningTimer = null;
}
class DateArraySequence {
    constructor(dateLikes) {
        this._dates = dateLikes.map(dateLike => {
            const date = new Date(dateLike);
            if (isNaN(date.getTime()))
                throw new Error('Invalid date');
            return date;
        }).sort((a, b) => a.getTime() - b.getTime());
    }
    nextDate(afterDate) {
        const nextIndex = this._dates.findIndex(d => d > afterDate);
        return nextIndex === -1 ? null : this._dates[nextIndex];
    }
}
export class CronosTask {
    constructor(sequenceOrDates) {
        this._listeners = {
            'started': new Set(),
            'stopped': new Set(),
            'run': new Set(),
            'ended': new Set(),
        };
        if (Array.isArray(sequenceOrDates))
            this._sequence = new DateArraySequence(sequenceOrDates);
        else if (typeof sequenceOrDates === 'string' ||
            typeof sequenceOrDates === 'number' ||
            sequenceOrDates instanceof Date)
            this._sequence = new DateArraySequence([sequenceOrDates]);
        else
            this._sequence = sequenceOrDates;
    }
    start() {
        this._updateTimestamp();
        addTask(this);
        runScheduledTasks();
        if (this._timestamp)
            this._emit('started');
        return this;
    }
    stop() {
        this._timestamp = undefined;
        removeTask(this);
        this._emit('stopped');
        return this;
    }
    get nextRun() {
        return this._timestamp ? new Date(this._timestamp) : undefined;
    }
    get isRunning() {
        return !!this._timestamp;
    }
    _runTask() {
        this._emit('run', this._timestamp);
    }
    _updateTimestamp() {
        const nextDate = this._sequence.nextDate(this._timestamp ? new Date(this._timestamp) : new Date());
        let timestamp = nextDate ? nextDate.getTime() : undefined;
        if (this._timestamp && timestamp && timestamp < (this._timestamp + 1000))
            timestamp = this._timestamp + 1000;
        this._timestamp = timestamp;
        if (!this._timestamp)
            this._emit('ended');
    }
    on(event, listener) {
        this._listeners[event].add(listener);
        return this;
    }
    off(event, listener) {
        this._listeners[event].delete(listener);
        return this;
    }
    _emit(event, ...args) {
        this._listeners[event].forEach((listener) => {
            listener.call(this, ...args);
        });
    }
}
//# sourceMappingURL=scheduler.js.map