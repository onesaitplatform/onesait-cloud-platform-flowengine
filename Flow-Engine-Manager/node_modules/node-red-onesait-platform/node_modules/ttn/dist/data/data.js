"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataClient = undefined;

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _sourceMapSupport2 = require("source-map-support");

var _events = require("events");

var _events2 = _interopRequireDefault(_events);

var _mqtt = require("mqtt");

var _mqtt2 = _interopRequireDefault(_mqtt);

var _debug = require("../utils/debug");

var _debug2 = _interopRequireDefault(_debug);

var _topic = require("./topic");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _sourceMapSupport2.install)(); // Copyright Â© 2017 The Things Network
// Use of this source code is governed by the MIT license that can be found in the LICENSE file.

/**
 * DataClient is a client for The Things Network data API.
 */
var DataClient = exports.DataClient = function () {

  /**
   * Creates a new DataClient and opens the MQTT connection.
   */


  /** @private */
  function DataClient(appID, appAccessKey, mqttAddress) {
    (0, _classCallCheck3.default)(this, DataClient);

    this.appID = appID;
    this.emitter = new _events2.default();

    var _mqttAddress$split = mqttAddress.split(":"),
        _mqttAddress$split2 = (0, _slicedToArray3.default)(_mqttAddress$split, 2),
        host = _mqttAddress$split2[0],
        _mqttAddress$split2$ = _mqttAddress$split2[1],
        port = _mqttAddress$split2$ === undefined ? "1883" : _mqttAddress$split2$;

    (0, _debug2.default)("connecting to mqtt host `%s` on port %d, using username `%s`", host, parseInt(port), appID);

    this.mqtt = _mqtt2.default.connect({
      host: host,
      port: parseInt(port),
      username: appID,
      password: appAccessKey
    });

    this.mqtt.on("error", this.onError.bind(this));
    this.mqtt.on("connect", this.onConnect.bind(this));
    this.mqtt.on("message", this.onMessage.bind(this));
    this.mqtt.on("reconnect", this.onReconnect.bind(this));
    this.mqtt.on("offline", this.onDisconnect.bind(this));
    this.mqtt.on("close", this.onClose.bind(this));
  }

  /**
   * Close the mqtt connection
   *
   * @param force - passing it to true will close the client right away, without waiting for the in-flight messages to be acked
   * @param callback - will be called when the client is closed
   */


  /** @private */

  /** @private */


  (0, _createClass3.default)(DataClient, [{
    key: "close",
    value: function close() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var callback = arguments[1];

      (0, _debug2.default)("closing mqtt client");
      return this.mqtt.end(force, callback);
    }

    /**
     * Same as close (for backwards compatibility).
     */

  }, {
    key: "end",
    value: function end(force, callback) {
      return this.close(force, callback);
    }

    /**
     * Starts listening to events.
     *
     * Possible events (application messages):
     *
     * - `uplink` (or `message`): Messages sent by the devices to the appliction.
     * - `activation`: An alias for the `activations` (see `event`)
     * - `event` (or `device`): Events that happen to devices. You can filter on
     *   the events by adding more parameters. For instance:
     *   - `downlink/scheduled`
     *   - `downlink/sent`
     *   - `activations`
     *   - `create`
     *   - `update`
     *   - `delete`
     *   - `down/acks`
     *   - `up/errors`
     *   - `down/errors`
     *   - `activations/errors`
     *
     * See [The MQTT API Reference](https://www.thethingsnetwork.org/docs/applications/mqtt/api.html)
     * for more information about these events and what their payloads look like.
     *
     * MQTT connection events:
     *
     * - `error`: An error occured / the initial connection failed.
     * - `connect`: A connection to the MQTT broker was established.
     * - `disconnect`: The connection to the MQTT broker was lost.
     * - `reconnect`: A reconnect to the MQTT broker is attempted.
     * - `close`: A connection (attempt) failed.
     *
     *
     * @param event - The name of the event to listen to.
     * @param [devID] - An optional devID. If not passed will subscribe to the event for all devices.
     * @param [name|field] - The name of the field to listen for on uplink or the event for device events.
     * @param callback - The callback to call when the event occurs.
     *
     * @example
     * // listens to all uplinks from all devices
     * client.on("uplink", function (devID, message) {})
     *
     * @example
     * // listens to all uplinks from the device with id `foo`
     * client.on("uplink", "foo", function (devID, message) {})
     *
     * @example
     * // listens to all device events for all devices
     * client.on("event", function (devID, message) {})
     *
     * @example
     * // listens to all device events for device with id `foo`
     * client.on("event", "foo", function (devID, message) {})
     *
     * @example
     * // listens to the `downlink/scheduled` events for device with id `foo`
     * client.on("event", "foo", "downlink/scheduled", function (devID, message) {})
     *
     * @example
     * // listens to the `downlink/scheduled` events for all devices
     * client.on("event", "+", "downlink/scheduled", function (devID, message) {})
     */

  }, {
    key: "on",
    value: function on(event) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return this.toggle.apply(this, [true, event].concat(args));
    }

    /**
     * Stop listening to events.
     * The argument structure is the same as for `on()`.
     */

  }, {
    key: "off",
    value: function off(event) {
      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return this.toggle.apply(this, [false, event].concat(args));
    }

    /**
     * @private
     * Toggles the subscription matching to the received arguments
     *
     */

  }, {
    key: "toggle",
    value: function toggle(on, event) {
      for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        args[_key3 - 2] = arguments[_key3];
      }

      if (args.length < 1) {
        throw new Error("Need at least one argument to on");
      }

      var rest = args.slice(0);

      var cb = rest.pop();

      var t = null;

      switch (event) {
        case "uplink":
        case "message":
          t = _topic.uplinkTopic.apply(undefined, (0, _toConsumableArray3.default)(rest));
          break;
        case "device":
        case "event":
        case "events":
          t = _topic.eventTopic.apply(undefined, (0, _toConsumableArray3.default)(rest));
          break;
        case "activation":
        case "activations":
          var _rest = (0, _slicedToArray3.default)(rest, 1),
              _rest$ = _rest[0],
              _devID = _rest$ === undefined ? _topic.wildcard : _rest$;

          t = (0, _topic.eventTopic)(_devID, "activations");
          break;
        case "error":
        case "connect":
        case "reconnect":
        case "disconnect":
        case "close":
          this.emitter.on(event, cb);
          return;
      }

      if (t === null) {
        throw new Error("Could not build topic");
      }

      if (on) {
        this.subscribe(t, cb);
      } else {
        this.unsubscribe(t, cb);
      }
    }

    /**
     * Send a downlink message to the device with the specified device ID.
     *
     * @param devID - The device ID of the device to send the downlink to.
     * @param payload - The raw payload as a Buffer, an Array of numbers, a hex string  or an object of payload fields.
     * @param port - The port to send the message on.
     * @param confirmed - Set to true for confirmed downlink.
     * @param schedule - Set to the scheduling you want to use (first, last or replace).
     */

  }, {
    key: "send",
    value: function send(devID, payload) {
      var port = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var confirmed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var schedule = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "replace";

      var t = (0, _topic.downlinkTopic)(this.appID, devID);
      var message = {
        port: port,
        confirmed: confirmed,
        schedule: schedule
      };

      if (Array.isArray(payload)) {
        message.payload_raw = new Buffer(payload).toString("base64");
      } else if (payload instanceof Buffer) {
        message.payload_raw = payload.toString("base64");
      } else if (typeof payload === "string") {
        message.payload_raw = new Buffer(payload, "hex").toString("base64");
      } else {
        message.payload_fields = payload;
      }

      (0, _debug2.default)("publishing message to %s: %O", t, message);

      this.mqtt.publish(t, (0, _stringify2.default)(message));
    }

    /**
     * @private
     * `onError` is called whenever there's an error in the MQTT client.
     */

  }, {
    key: "onError",
    value: function onError(err) {
      (0, _debug2.default)("mqtt client received error: %s", err);
      this.emitter.emit("error", err);
    }

    /**
     * @private
     * `onConnect` is called whenever the MQTT client (re-)connects.
     */

  }, {
    key: "onConnect",
    value: function onConnect(ack) {
      (0, _debug2.default)("mqtt client connected");
      this.emitter.emit("connect", ack);
    }

    /**
     * @private
     * `onReconnect` is called whenever the MQTT client starts reconnecting.
     */

  }, {
    key: "onReconnect",
    value: function onReconnect() {
      (0, _debug2.default)("mqtt client reconnecting");
      this.emitter.emit("reconnect", undefined);
    }

    /**
     * @private
     * `onDisconnect` is called whenever the MQTT client lost its connection,
     * after the keepalive has timed out.
     */

  }, {
    key: "onDisconnect",
    value: function onDisconnect() {
      (0, _debug2.default)("mqtt client disconnected");
      this.emitter.emit("disconnect", undefined);
    }

    /**
     * @private
     * `onClose` is called after the MQTT disconnects.
     */

  }, {
    key: "onClose",
    value: function onClose() {
      (0, _debug2.default)("mqtt client disconnected");
      this.emitter.emit("close", undefined);
    }

    /**
     * @private
     * `onMessage` is called when a new message is received from any subscription.
     */

  }, {
    key: "onMessage",
    value: function onMessage(topic, message) {
      var _this = this;

      var payload = JSON.parse(message.toString());

      if (payload && typeof payload.payload_raw === "string") {
        payload.payload_raw = new Buffer(payload.payload_raw, "base64");
      }

      (0, _debug2.default)("received message on topic `%s`: %O", topic, payload);

      var dev = (0, _topic.devID)(topic);
      (0, _topic.validWildcards)(topic).forEach(function (topic) {
        return _this.emitter.emit(topic, dev, payload);
      });
    }

    /**
     * @private
     * `subscribe` subscribes the mqtt client to the specified topic and hooks up
     * the callback in the event emitter.
     */

  }, {
    key: "subscribe",
    value: function subscribe(topic, cb) {
      (0, _debug2.default)("subscribing to messages on topic `%s`", topic);
      this.mqtt.subscribe(topic);
      this.emitter.on(topic, cb);
    }

    /**
     * @private
     * `unsubscribe` unsubscribes the mqtt client from the specified topic and
     * removes the callback from the event emitter.
     */

  }, {
    key: "unsubscribe",
    value: function unsubscribe(topic, cb) {
      (0, _debug2.default)("unsubscribing from messages on topic `%s`", topic);
      this.mqtt.unsubscribe(topic);
      this.emitter.removeListener(topic, cb);
    }
  }]);
  return DataClient;
}();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kYXRhL2RhdGEuanMiXSwibmFtZXMiOlsiRGF0YUNsaWVudCIsImFwcElEIiwiYXBwQWNjZXNzS2V5IiwibXF0dEFkZHJlc3MiLCJlbWl0dGVyIiwic3BsaXQiLCJob3N0IiwicG9ydCIsInBhcnNlSW50IiwibXF0dCIsImNvbm5lY3QiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwib24iLCJvbkVycm9yIiwiYmluZCIsIm9uQ29ubmVjdCIsIm9uTWVzc2FnZSIsIm9uUmVjb25uZWN0Iiwib25EaXNjb25uZWN0Iiwib25DbG9zZSIsImZvcmNlIiwiY2FsbGJhY2siLCJlbmQiLCJjbG9zZSIsImV2ZW50IiwiYXJncyIsInRvZ2dsZSIsImxlbmd0aCIsIkVycm9yIiwicmVzdCIsImNiIiwicG9wIiwidCIsImRldklEIiwic3Vic2NyaWJlIiwidW5zdWJzY3JpYmUiLCJwYXlsb2FkIiwiY29uZmlybWVkIiwic2NoZWR1bGUiLCJtZXNzYWdlIiwiQXJyYXkiLCJpc0FycmF5IiwicGF5bG9hZF9yYXciLCJCdWZmZXIiLCJ0b1N0cmluZyIsInBheWxvYWRfZmllbGRzIiwicHVibGlzaCIsImVyciIsImVtaXQiLCJhY2siLCJ1bmRlZmluZWQiLCJ0b3BpYyIsIkpTT04iLCJwYXJzZSIsImRldiIsImZvckVhY2giLCJyZW1vdmVMaXN0ZW5lciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFFQTs7OzttQ0FWQTtBQUNBOztBQThCQTs7O0lBR2FBLFUsV0FBQUEsVTs7QUFVWDs7Ozs7QUFOQTtBQVNBLHNCQUFhQyxLQUFiLEVBQTZCQyxZQUE3QixFQUFvREMsV0FBcEQsRUFBaUY7QUFBQTs7QUFDL0UsU0FBS0YsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsU0FBS0csT0FBTCxHQUFlLHNCQUFmOztBQUYrRSw2QkFJL0NELFlBQVlFLEtBQVosQ0FBa0IsR0FBbEIsQ0FKK0M7QUFBQTtB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O0FBRUEsVUFBSVIsV0FBVyxPQUFPQSxRQUFRTSxXQUFmLEtBQStCLFFBQTlDLEVBQXdEO0FBQ3RETixnQkFBUU0sV0FBUixHQUFzQixJQUFJQyxNQUFKLENBQVdQLFFBQVFNLFdBQW5CLEVBQWdDLFFBQWhDLENBQXRCO0FBQ0Q7O0FBRUQsMkJBQU0sb0NBQU4sRUFBNENTLEtBQTVDLEVBQW1EZixPQUFuRDs7QUFFQSxVQUFNa0IsTUFBTSxrQkFBTUgsS0FBTixDQUFaO0FBQ0EsaUNBQWVBLEtBQWYsRUFBc0JJLE9BQXRCLENBQThCO0FBQUEsZUFBUyxNQUFLcEQsT0FBTCxDQUFhNkMsSUFBYixDQUFrQkcsS0FBbEIsRUFBeUJHLEdBQXpCLEVBQThCbEIsT0FBOUIsQ0FBVDtBQUFBLE9BQTlCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OzhCQUtXZSxLLEVBQWdCckIsRSxFQUFzQjtBQUMvQywyQkFBTSx1Q0FBTixFQUErQ3FCLEtBQS9DO0FBQ0EsV0FBSzNDLElBQUwsQ0FBVTBCLFNBQVYsQ0FBb0JpQixLQUFwQjtBQUNBLFdBQUtoRCxPQUFMLENBQWFTLEVBQWIsQ0FBZ0J1QyxLQUFoQixFQUF1QnJCLEVBQXZCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O2dDQUthcUIsSyxFQUFnQnJCLEUsRUFBc0I7QUFDakQsMkJBQU0sMkNBQU4sRUFBbURxQixLQUFuRDtBQUNBLFdBQUszQyxJQUFMLENBQVUyQixXQUFWLENBQXNCZ0IsS0FBdEI7QUFDQSxXQUFLaEQsT0FBTCxDQUFhcUQsY0FBYixDQUE0QkwsS0FBNUIsRUFBbUNyQixFQUFuQztBQUNEIiwiZmlsZSI6ImRhdGEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgwqkgMjAxNyBUaGUgVGhpbmdzIE5ldHdvcmtcbi8vIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IHRoZSBNSVQgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlLlxuXG4vLyBAZmxvd1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJldmVudHNcIlxuaW1wb3J0IG1xdHQgZnJvbSBcIm1xdHRcIlxuXG5pbXBvcnQgZGVidWcgZnJvbSBcIi4uL3V0aWxzL2RlYnVnXCJcblxuaW1wb3J0IHsgZGV2SUQsIHdpbGRjYXJkLCB1cGxpbmtUb3BpYywgZXZlbnRUb3BpYywgZG93bmxpbmtUb3BpYywgdmFsaWRXaWxkY2FyZHMgfSBmcm9tIFwiLi90b3BpY1wiXG5cbnR5cGUgRGV2aWNlSUQgPSBzdHJpbmdcbnR5cGUgQ29ubmFjayA9IHtcbiAgc2Vzc2lvblByZXNlbnQgOiBib29sZWFuLFxufVxuXG50eXBlIFBheWxvYWRBcnJheSA9IEFycmF5PG51bWJlcj5cbnR5cGUgUGF5bG9hZFJhdyA9IEJ1ZmZlclxudHlwZSBQYXlsb2FkRmllbGRzID0geyBbc3RyaW5nXTogYW55IH1cbnR5cGUgU2NoZWR1bGUgPSBcInJlcGxhY2VcIiB8IFwiZmlyc3RcIiB8IFwibGFzdFwiXG5cbnR5cGUgRG93bmxpbmtNZXNzYWdlID0ge1xuICBwb3J0IDogbnVtYmVyLFxuICBwYXlsb2FkX3Jhdz8gOiBzdHJpbmcsXG4gIHBheWxvYWRfZmllbGRzPyA6IFBheWxvYWRGaWVsZHMsXG4gIGNvbmZpcm1lZD8gOiBib29sZWFuLFxuICBzY2hlZHVsZT8gOiBTY2hlZHVsZSxcbn1cblxuXG4vKipcbiAqIERhdGFDbGllbnQgaXMgYSBjbGllbnQgZm9yIFRoZSBUaGluZ3MgTmV0d29yayBkYXRhIEFQSS5cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFDbGllbnQge1xuICAvKiogQHByaXZhdGUgKi9cbiAgYXBwSUQgOiBzdHJpbmdcblxuICAvKiogQHByaXZhdGUgKi9cbiAgZW1pdHRlciA6IEV2ZW50RW1pdHRlclxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBtcXR0IDogYW55XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgRGF0YUNsaWVudCBhbmQgb3BlbnMgdGhlIE1RVFQgY29ubmVjdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChhcHBJRCA6IHN0cmluZywgYXBwQWNjZXNzS2V5IDogc3RyaW5nLCBtcXR0QWRkcmVzcyA6IHN0cmluZykgOiB2b2lkIHtcbiAgICB0aGlzLmFwcElEID0gYXBwSURcbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKClcblxuICAgIGNvbnN0IFsgaG9zdCwgcG9ydCA9IFwiMTg4M1wiIF0gPSBtcXR0QWRkcmVzcy5zcGxpdChcIjpcIilcblxuICAgIGRlYnVnKFwiY29ubmVjdGluZyB0byBtcXR0IGhvc3QgYCVzYCBvbiBwb3J0ICVkLCB1c2luZyB1c2VybmFtZSBgJXNgXCIsIGhvc3QsIHBhcnNlSW50KHBvcnQpLCBhcHBJRClcblxuICAgIHRoaXMubXF0dCA9IG1xdHQuY29ubmVjdCh7XG4gICAgICBob3N0LFxuICAgICAgcG9ydDogcGFyc2VJbnQocG9ydCksXG4gICAgICB1c2VybmFtZTogYXBwSUQsXG4gICAgICBwYXNzd29yZDogYXBwQWNjZXNzS2V5LFxuICAgIH0pXG5cbiAgICB0aGlzLm1xdHQub24oXCJlcnJvclwiLCB0aGlzLm9uRXJyb3IuYmluZCh0aGlzKSlcbiAgICB0aGlzLm1xdHQub24oXCJjb25uZWN0XCIsIHRoaXMub25Db25uZWN0LmJpbmQodGhpcykpXG4gICAgdGhpcy5tcXR0Lm9uKFwibWVzc2FnZVwiLCB0aGlzLm9uTWVzc2FnZS5iaW5kKHRoaXMpKVxuICAgIHRoaXMubXF0dC5vbihcInJlY29ubmVjdFwiLCB0aGlzLm9uUmVjb25uZWN0LmJpbmQodGhpcykpXG4gICAgdGhpcy5tcXR0Lm9uKFwib2ZmbGluZVwiLCB0aGlzLm9uRGlzY29ubmVjdC5iaW5kKHRoaXMpKVxuICAgIHRoaXMubXF0dC5vbihcImNsb3NlXCIsIHRoaXMub25DbG9zZS5iaW5kKHRoaXMpKVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlIHRoZSBtcXR0IGNvbm5lY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIGZvcmNlIC0gcGFzc2luZyBpdCB0byB0cnVlIHdpbGwgY2xvc2UgdGhlIGNsaWVudCByaWdodCBhd2F5LCB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSBpbi1mbGlnaHQgbWVzc2FnZXMgdG8gYmUgYWNrZWRcbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgY2xpZW50IGlzIGNsb3NlZFxuICAgKi9cbiAgY2xvc2UgKGZvcmNlIDogP2Jvb2xlYW4gPSBmYWxzZSwgY2FsbGJhY2sgOiA/RnVuY3Rpb24pIHtcbiAgICBkZWJ1ZyhcImNsb3NpbmcgbXF0dCBjbGllbnRcIilcbiAgICByZXR1cm4gdGhpcy5tcXR0LmVuZChmb3JjZSwgY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogU2FtZSBhcyBjbG9zZSAoZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KS5cbiAgICovXG4gIGVuZCAoZm9yY2UgOiA/Ym9vbGVhbiwgY2FsbGJhY2sgOiA/RnVuY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9zZShmb3JjZSwgY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIGxpc3RlbmluZyB0byBldmVudHMuXG4gICAqXG4gICAqIFBvc3NpYmxlIGV2ZW50cyAoYXBwbGljYXRpb24gbWVzc2FnZXMpOlxuICAgKlxuICAgKiAtIGB1cGxpbmtgIChvciBgbWVzc2FnZWApOiBNZXNzYWdlcyBzZW50IGJ5IHRoZSBkZXZpY2VzIHRvIHRoZSBhcHBsaWN0aW9uLlxuICAgKiAtIGBhY3RpdmF0aW9uYDogQW4gYWxpYXMgZm9yIHRoZSBgYWN0aXZhdGlvbnNgIChzZWUgYGV2ZW50YClcbiAgICogLSBgZXZlbnRgIChvciBgZGV2aWNlYCk6IEV2ZW50cyB0aGF0IGhhcHBlbiB0byBkZXZpY2VzLiBZb3UgY2FuIGZpbHRlciBvblxuICAgKiAgIHRoZSBldmVudHMgYnkgYWRkaW5nIG1vcmUgcGFyYW1ldGVycy4gRm9yIGluc3RhbmNlOlxuICAgKiAgIC0gYGRvd25saW5rL3NjaGVkdWxlZGBcbiAgICogICAtIGBkb3dubGluay9zZW50YFxuICAgKiAgIC0gYGFjdGl2YXRpb25zYFxuICAgKiAgIC0gYGNyZWF0ZWBcbiAgICogICAtIGB1cGRhdGVgXG4gICAqICAgLSBgZGVsZXRlYFxuICAgKiAgIC0gYGRvd24vYWNrc2BcbiAgICogICAtIGB1cC9lcnJvcnNgXG4gICAqICAgLSBgZG93bi9lcnJvcnNgXG4gICAqICAgLSBgYWN0aXZhdGlvbnMvZXJyb3JzYFxuICAgKlxuICAgKiBTZWUgW1RoZSBNUVRUIEFQSSBSZWZlcmVuY2VdKGh0dHBzOi8vd3d3LnRoZXRoaW5nc25ldHdvcmsub3JnL2RvY3MvYXBwbGljYXRpb25zL21xdHQvYXBpLmh0bWwpXG4gICAqIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZXNlIGV2ZW50cyBhbmQgd2hhdCB0aGVpciBwYXlsb2FkcyBsb29rIGxpa2UuXG4gICAqXG4gICAqIE1RVFQgY29ubmVjdGlvbiBldmVudHM6XG4gICAqXG4gICAqIC0gYGVycm9yYDogQW4gZXJyb3Igb2NjdXJlZCAvIHRoZSBpbml0aWFsIGNvbm5lY3Rpb24gZmFpbGVkLlxuICAgKiAtIGBjb25uZWN0YDogQSBjb25uZWN0aW9uIHRvIHRoZSBNUVRUIGJyb2tlciB3YXMgZXN0YWJsaXNoZWQuXG4gICAqIC0gYGRpc2Nvbm5lY3RgOiBUaGUgY29ubmVjdGlvbiB0byB0aGUgTVFUVCBicm9rZXIgd2FzIGxvc3QuXG4gICAqIC0gYHJlY29ubmVjdGA6IEEgcmVjb25uZWN0IHRvIHRoZSBNUVRUIGJyb2tlciBpcyBhdHRlbXB0ZWQuXG4gICAqIC0gYGNsb3NlYDogQSBjb25uZWN0aW9uIChhdHRlbXB0KSBmYWlsZWQuXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gdG8uXG4gICAqIEBwYXJhbSBbZGV2SURdIC0gQW4gb3B0aW9uYWwgZGV2SUQuIElmIG5vdCBwYXNzZWQgd2lsbCBzdWJzY3JpYmUgdG8gdGhlIGV2ZW50IGZvciBhbGwgZGV2aWNlcy5cbiAgICogQHBhcmFtIFtuYW1lfGZpZWxkXSAtIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBsaXN0ZW4gZm9yIG9uIHVwbGluayBvciB0aGUgZXZlbnQgZm9yIGRldmljZSBldmVudHMuXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gbGlzdGVucyB0byBhbGwgdXBsaW5rcyBmcm9tIGFsbCBkZXZpY2VzXG4gICAqIGNsaWVudC5vbihcInVwbGlua1wiLCBmdW5jdGlvbiAoZGV2SUQsIG1lc3NhZ2UpIHt9KVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBsaXN0ZW5zIHRvIGFsbCB1cGxpbmtzIGZyb20gdGhlIGRldmljZSB3aXRoIGlkIGBmb29gXG4gICAqIGNsaWVudC5vbihcInVwbGlua1wiLCBcImZvb1wiLCBmdW5jdGlvbiAoZGV2SUQsIG1lc3NhZ2UpIHt9KVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBsaXN0ZW5zIHRvIGFsbCBkZXZpY2UgZXZlbnRzIGZvciBhbGwgZGV2aWNlc1xuICAgKiBjbGllbnQub24oXCJldmVudFwiLCBmdW5jdGlvbiAoZGV2SUQsIG1lc3NhZ2UpIHt9KVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBsaXN0ZW5zIHRvIGFsbCBkZXZpY2UgZXZlbnRzIGZvciBkZXZpY2Ugd2l0aCBpZCBgZm9vYFxuICAgKiBjbGllbnQub24oXCJldmVudFwiLCBcImZvb1wiLCBmdW5jdGlvbiAoZGV2SUQsIG1lc3NhZ2UpIHt9KVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBsaXN0ZW5zIHRvIHRoZSBgZG93bmxpbmsvc2NoZWR1bGVkYCBldmVudHMgZm9yIGRldmljZSB3aXRoIGlkIGBmb29gXG4gICAqIGNsaWVudC5vbihcImV2ZW50XCIsIFwiZm9vXCIsIFwiZG93bmxpbmsvc2NoZWR1bGVkXCIsIGZ1bmN0aW9uIChkZXZJRCwgbWVzc2FnZSkge30pXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGxpc3RlbnMgdG8gdGhlIGBkb3dubGluay9zY2hlZHVsZWRgIGV2ZW50cyBmb3IgYWxsIGRldmljZXNcbiAgICogY2xpZW50Lm9uKFwiZXZlbnRcIiwgXCIrXCIsIFwiZG93bmxpbmsvc2NoZWR1bGVkXCIsIGZ1bmN0aW9uIChkZXZJRCwgbWVzc2FnZSkge30pXG4gICAqL1xuICBvbiAoZXZlbnQgOiBzdHJpbmcsIC4uLmFyZ3MgOiBBcnJheTwqPikgOiB2b2lkIHtcbiAgICByZXR1cm4gdGhpcy50b2dnbGUodHJ1ZSwgZXZlbnQsIC4uLmFyZ3MpXG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsaXN0ZW5pbmcgdG8gZXZlbnRzLlxuICAgKiBUaGUgYXJndW1lbnQgc3RydWN0dXJlIGlzIHRoZSBzYW1lIGFzIGZvciBgb24oKWAuXG4gICAqL1xuICBvZmYgKGV2ZW50IDogc3RyaW5nLCAuLi5hcmdzIDogQXJyYXk8Kj4pIDogdm9pZCB7XG4gICAgcmV0dXJuIHRoaXMudG9nZ2xlKGZhbHNlLCBldmVudCwgLi4uYXJncylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBUb2dnbGVzIHRoZSBzdWJzY3JpcHRpb24gbWF0Y2hpbmcgdG8gdGhlIHJlY2VpdmVkIGFyZ3VtZW50c1xuICAgKlxuICAgKi9cbiAgdG9nZ2xlIChvbiA6IGJvb2xlYW4sIGV2ZW50IDogc3RyaW5nLCAuLi5hcmdzIDogQXJyYXk8Kj4pIDogdm9pZCB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmVlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQgdG8gb25cIilcbiAgICB9XG5cbiAgICBjb25zdCBbIC4uLnJlc3QgXSA9IGFyZ3NcbiAgICBjb25zdCBjYiA9IHJlc3QucG9wKClcblxuICAgIGxldCB0ID0gbnVsbFxuXG4gICAgc3dpdGNoIChldmVudCkge1xuICAgIGNhc2UgXCJ1cGxpbmtcIjpcbiAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgdCA9IHVwbGlua1RvcGljKC4uLnJlc3QpXG4gICAgICBicmVha1xuICAgIGNhc2UgXCJkZXZpY2VcIjpcbiAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICBjYXNlIFwiZXZlbnRzXCI6XG4gICAgICB0ID0gZXZlbnRUb3BpYyguLi5yZXN0KVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiYWN0aXZhdGlvblwiOlxuICAgIGNhc2UgXCJhY3RpdmF0aW9uc1wiOlxuICAgICAgY29uc3QgWyBkZXZJRCA9IHdpbGRjYXJkIF0gPSByZXN0XG4gICAgICB0ID0gZXZlbnRUb3BpYyhkZXZJRCwgXCJhY3RpdmF0aW9uc1wiKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICBjYXNlIFwiY29ubmVjdFwiOlxuICAgIGNhc2UgXCJyZWNvbm5lY3RcIjpcbiAgICBjYXNlIFwiZGlzY29ubmVjdFwiOlxuICAgIGNhc2UgXCJjbG9zZVwiOlxuICAgICAgdGhpcy5lbWl0dGVyLm9uKGV2ZW50LCBjYilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgYnVpbGQgdG9waWNcIilcbiAgICB9XG5cbiAgICBpZiAob24pIHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlKHQsIGNiKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKHQsIGNiKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgZG93bmxpbmsgbWVzc2FnZSB0byB0aGUgZGV2aWNlIHdpdGggdGhlIHNwZWNpZmllZCBkZXZpY2UgSUQuXG4gICAqXG4gICAqIEBwYXJhbSBkZXZJRCAtIFRoZSBkZXZpY2UgSUQgb2YgdGhlIGRldmljZSB0byBzZW5kIHRoZSBkb3dubGluayB0by5cbiAgICogQHBhcmFtIHBheWxvYWQgLSBUaGUgcmF3IHBheWxvYWQgYXMgYSBCdWZmZXIsIGFuIEFycmF5IG9mIG51bWJlcnMsIGEgaGV4IHN0cmluZyAgb3IgYW4gb2JqZWN0IG9mIHBheWxvYWQgZmllbGRzLlxuICAgKiBAcGFyYW0gcG9ydCAtIFRoZSBwb3J0IHRvIHNlbmQgdGhlIG1lc3NhZ2Ugb24uXG4gICAqIEBwYXJhbSBjb25maXJtZWQgLSBTZXQgdG8gdHJ1ZSBmb3IgY29uZmlybWVkIGRvd25saW5rLlxuICAgKiBAcGFyYW0gc2NoZWR1bGUgLSBTZXQgdG8gdGhlIHNjaGVkdWxpbmcgeW91IHdhbnQgdG8gdXNlIChmaXJzdCwgbGFzdCBvciByZXBsYWNlKS5cbiAgICovXG4gIHNlbmQgKGRldklEIDogRGV2aWNlSUQsIHBheWxvYWQgOiBQYXlsb2FkQXJyYXkgfCBQYXlsb2FkUmF3IHwgU3RyaW5nIHwgUGF5bG9hZEZpZWxkcywgcG9ydCA6IG51bWJlciA9IDEsIGNvbmZpcm1lZCA6IGJvb2xlYW4gPSBmYWxzZSwgc2NoZWR1bGUgOiBTY2hlZHVsZSA9IFwicmVwbGFjZVwiKSB7XG4gICAgY29uc3QgdCA9IGRvd25saW5rVG9waWModGhpcy5hcHBJRCwgZGV2SUQpXG4gICAgY29uc3QgbWVzc2FnZSA6IERvd25saW5rTWVzc2FnZSA9IHtcbiAgICAgIHBvcnQsXG4gICAgICBjb25maXJtZWQsXG4gICAgICBzY2hlZHVsZSxcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgICAgbWVzc2FnZS5wYXlsb2FkX3JhdyA9IG5ldyBCdWZmZXIocGF5bG9hZCkudG9TdHJpbmcoXCJiYXNlNjRcIilcbiAgICB9IGVsc2UgaWYgKHBheWxvYWQgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgIG1lc3NhZ2UucGF5bG9hZF9yYXcgPSBwYXlsb2FkLnRvU3RyaW5nKFwiYmFzZTY0XCIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbWVzc2FnZS5wYXlsb2FkX3JhdyA9IG5ldyBCdWZmZXIocGF5bG9hZCwgXCJoZXhcIikudG9TdHJpbmcoXCJiYXNlNjRcIilcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZS5wYXlsb2FkX2ZpZWxkcyA9IHBheWxvYWRcbiAgICB9XG5cbiAgICBkZWJ1ZyhcInB1Ymxpc2hpbmcgbWVzc2FnZSB0byAlczogJU9cIiwgdCwgbWVzc2FnZSlcblxuICAgIHRoaXMubXF0dC5wdWJsaXNoKHQsIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGBvbkVycm9yYCBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlcmUncyBhbiBlcnJvciBpbiB0aGUgTVFUVCBjbGllbnQuXG4gICAqL1xuICBvbkVycm9yIChlcnIgOiBhbnkpIDogdm9pZCB7XG4gICAgZGVidWcoXCJtcXR0IGNsaWVudCByZWNlaXZlZCBlcnJvcjogJXNcIiwgZXJyKVxuICAgIHRoaXMuZW1pdHRlci5lbWl0KFwiZXJyb3JcIiwgZXJyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGBvbkNvbm5lY3RgIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgTVFUVCBjbGllbnQgKHJlLSljb25uZWN0cy5cbiAgICovXG4gIG9uQ29ubmVjdCAoYWNrIDogQ29ubmFjaykgOiB2b2lkIHtcbiAgICBkZWJ1ZyhcIm1xdHQgY2xpZW50IGNvbm5lY3RlZFwiKVxuICAgIHRoaXMuZW1pdHRlci5lbWl0KFwiY29ubmVjdFwiLCBhY2spXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogYG9uUmVjb25uZWN0YCBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIE1RVFQgY2xpZW50IHN0YXJ0cyByZWNvbm5lY3RpbmcuXG4gICAqL1xuICBvblJlY29ubmVjdCAoKSA6IHZvaWQge1xuICAgIGRlYnVnKFwibXF0dCBjbGllbnQgcmVjb25uZWN0aW5nXCIpXG4gICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJyZWNvbm5lY3RcIiwgdW5kZWZpbmVkKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGBvbkRpc2Nvbm5lY3RgIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgTVFUVCBjbGllbnQgbG9zdCBpdHMgY29ubmVjdGlvbixcbiAgICogYWZ0ZXIgdGhlIGtlZXBhbGl2ZSBoYXMgdGltZWQgb3V0LlxuICAgKi9cbiAgb25EaXNjb25uZWN0ICgpIDogdm9pZCB7XG4gICAgZGVidWcoXCJtcXR0IGNsaWVudCBkaXNjb25uZWN0ZWRcIilcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdChcImRpc2Nvbm5lY3RcIiwgdW5kZWZpbmVkKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGBvbkNsb3NlYCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIE1RVFQgZGlzY29ubmVjdHMuXG4gICAqL1xuICBvbkNsb3NlICgpIDogdm9pZCB7XG4gICAgZGVidWcoXCJtcXR0IGNsaWVudCBkaXNjb25uZWN0ZWRcIilcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdChcImNsb3NlXCIsIHVuZGVmaW5lZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBgb25NZXNzYWdlYCBpcyBjYWxsZWQgd2hlbiBhIG5ldyBtZXNzYWdlIGlzIHJlY2VpdmVkIGZyb20gYW55IHN1YnNjcmlwdGlvbi5cbiAgICovXG4gIG9uTWVzc2FnZSAodG9waWMgOiBzdHJpbmcsIG1lc3NhZ2UgOiBhbnkpIDogdm9pZCB7XG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UobWVzc2FnZS50b1N0cmluZygpKVxuXG4gICAgaWYgKHBheWxvYWQgJiYgdHlwZW9mIHBheWxvYWQucGF5bG9hZF9yYXcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHBheWxvYWQucGF5bG9hZF9yYXcgPSBuZXcgQnVmZmVyKHBheWxvYWQucGF5bG9hZF9yYXcsIFwiYmFzZTY0XCIpXG4gICAgfVxuXG4gICAgZGVidWcoXCJyZWNlaXZlZCBtZXNzYWdlIG9uIHRvcGljIGAlc2A6ICVPXCIsIHRvcGljLCBwYXlsb2FkKVxuXG4gICAgY29uc3QgZGV2ID0gZGV2SUQodG9waWMpXG4gICAgdmFsaWRXaWxkY2FyZHModG9waWMpLmZvckVhY2godG9waWMgPT4gdGhpcy5lbWl0dGVyLmVtaXQodG9waWMsIGRldiwgcGF5bG9hZCkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogYHN1YnNjcmliZWAgc3Vic2NyaWJlcyB0aGUgbXF0dCBjbGllbnQgdG8gdGhlIHNwZWNpZmllZCB0b3BpYyBhbmQgaG9va3MgdXBcbiAgICogdGhlIGNhbGxiYWNrIGluIHRoZSBldmVudCBlbWl0dGVyLlxuICAgKi9cbiAgc3Vic2NyaWJlICh0b3BpYyA6IHN0cmluZywgY2IgOiBGdW5jdGlvbikgOiB2b2lkIHtcbiAgICBkZWJ1ZyhcInN1YnNjcmliaW5nIHRvIG1lc3NhZ2VzIG9uIHRvcGljIGAlc2BcIiwgdG9waWMpXG4gICAgdGhpcy5tcXR0LnN1YnNjcmliZSh0b3BpYylcbiAgICB0aGlzLmVtaXR0ZXIub24odG9waWMsIGNiKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGB1bnN1YnNjcmliZWAgdW5zdWJzY3JpYmVzIHRoZSBtcXR0IGNsaWVudCBmcm9tIHRoZSBzcGVjaWZpZWQgdG9waWMgYW5kXG4gICAqIHJlbW92ZXMgdGhlIGNhbGxiYWNrIGZyb20gdGhlIGV2ZW50IGVtaXR0ZXIuXG4gICAqL1xuICB1bnN1YnNjcmliZSAodG9waWMgOiBzdHJpbmcsIGNiIDogRnVuY3Rpb24pIDogdm9pZCB7XG4gICAgZGVidWcoXCJ1bnN1YnNjcmliaW5nIGZyb20gbWVzc2FnZXMgb24gdG9waWMgYCVzYFwiLCB0b3BpYylcbiAgICB0aGlzLm1xdHQudW5zdWJzY3JpYmUodG9waWMpXG4gICAgdGhpcy5lbWl0dGVyLnJlbW92ZUxpc3RlbmVyKHRvcGljLCBjYilcbiAgfVxufVxuIl19