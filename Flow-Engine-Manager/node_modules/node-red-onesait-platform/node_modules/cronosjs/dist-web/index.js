const sortAsc = (a, b) => a - b;

const predefinedCronStrings = {
  '@yearly': '0 0 0 1 1 * *',
  '@annually': '0 0 0 1 1 * *',
  '@monthly': '0 0 0 1 * * *',
  '@weekly': '0 0 0 * * 0 *',
  '@daily': '0 0 0 * * * *',
  '@midnight': '0 0 0 * * * *',
  '@hourly': '0 0 * * * * *'
};
const monthReplacements = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
const monthReplacementRegex = new RegExp(monthReplacements.join('|'), 'g');
const dayOfWeekReplacements = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
const dayOfWeekReplacementRegex = new RegExp(dayOfWeekReplacements.join('|'), 'g');
function _parse(cronstring) {
  let expr = cronstring.trim().toLowerCase();

  if (predefinedCronStrings[expr]) {
    expr = predefinedCronStrings[expr];
  }

  const fields = expr.split(/\s+/g);

  if (fields.length < 5 || fields.length > 7) {
    throw new Error('Expression must have at least 5 fields, and no more than 7 fields');
  }

  switch (fields.length) {
    case 5:
      fields.unshift('0');

    case 6:
      fields.push('*');
  }

  return new CronosExpression(cronstring, secondsOrMinutesParser(fields[0]), secondsOrMinutesParser(fields[1]), hoursParser(fields[2]), daysParser(fields[3], fields[5]), monthsParser(fields[4]), yearsParser(fields[6]));
}

function expandFieldItem(item, first, last) {
  let allowCyclicRange = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  let transformer = arguments.length > 4 ? arguments[4] : undefined;
  let start = first,
      end = last,
      every = 1;
  const [match, all, startFrom, range, step] = item.match(/^(?:(\*)|([0-9]+)|([0-9]+-[0-9]+))(?:\/([1-9][0-9]*))?$/) || [];
  if (!match) throw new Error('Field item invalid');

  if (startFrom) {
    start = parseInt(startFrom, 10);
    start = transformer ? transformer(start) : start;
    if (start < first || start > last) throw new Error('Field item start from value invalid');
    end = step ? last : start;
  } else if (range) {
    const [rangeStart, rangeEnd] = range.split('-').map(x => {
      const n = parseInt(x, 10);
      return transformer ? transformer(n) : n;
    });

    if (rangeStart < first || rangeStart > last || rangeEnd < first || rangeEnd > last || rangeEnd < rangeStart && !allowCyclicRange) {
      throw new Error('Field item range invalid');
    }

    start = rangeStart;
    end = rangeEnd;
  }

  if (step) {
    every = parseInt(step, 10);
  }

  const rangeLength = end < start ? last - start + (end - first) + 1 : end - start;
  return Array(Math.floor(rangeLength / every) + 1).fill(0).map((_, i) => first + (start - first + every * i) % (last - first + 1));
}

function secondsOrMinutesParser(field) {
  const allowed = new Set();

  for (const item of field.split(',')) {
    for (const n of expandFieldItem(item, 0, 59, true)) {
      allowed.add(n);
    }
  }

  return Array.from(allowed).sort(sortAsc);
}

function hoursParser(field) {
  const allowed = new Set();

  for (const item of field.split(',')) {
    for (const n of expandFieldItem(item, 0, 23, true)) {
      allowed.add(n);
    }
  }

  return Array.from(allowed).sort(sortAsc);
}

function daysParser(daysOfMonthField, daysOfWeekField) {
  const expr = {
    include: [],
    last: false,
    lastWeekday: false,
    nearestWeekdays: [],
    daysOfWeek: [],
    lastDaysOfWeek: [],
    nthDaysOfWeek: []
  };
  const include = new Set(),
        nearestWeekdays = new Set(),
        daysOfWeek = new Set(),
        lastDaysOfWeek = new Set(),
        nthDaysOfWeek = new Set(); // days of month      

  let anyDay = true;

  for (let item of daysOfMonthField.split(',')) {
    let weekday = false;
    if (item === '*') continue;
    anyDay = false;

    if (item === 'l') {
      expr.last = true;
      continue;
    }

    if (item === 'lw') {
      expr.lastWeekday = true;
      continue;
    }

    if (item.endsWith('w')) {
      weekday = true;
      item = item.slice(0, -1);
    }

    for (const n of expandFieldItem(item, 1, 31)) {
      weekday ? nearestWeekdays.add(n) : include.add(n);
    }
  } // days of week


  const normalisedDaysOfWeekField = daysOfWeekField.replace(dayOfWeekReplacementRegex, match => dayOfWeekReplacements.indexOf(match) + '');
  let anyDaysOfWeek = true;

  for (let item of normalisedDaysOfWeekField.split(',')) {
    let last = false;
    let nth = 0;
    if (item === '*') continue;
    anyDaysOfWeek = false;

    if (item.endsWith('l')) {
      last = true;
      item = item.slice(0, -1);
    } else if (item.includes('#')) {
      let match = item.match(/^.+#([1-5])$/);
      if (!match) throw new Error('Field item nth of month (#) invalid');
      nth = parseInt(match[1], 10);
      item = item.slice(0, item.indexOf('#'));
    }

    let days = expandFieldItem(item, 0, 6, true, n => n === 7 ? 0 : n);

    if (nth) {
      for (const n of days) {
        const hash = n + '/' + nth;

        if (!nthDaysOfWeek.has(hash)) {
          nthDaysOfWeek.add(hash);
          expr.nthDaysOfWeek.push([n, nth]);
        }
      }

      continue;
    }

    const set = last ? lastDaysOfWeek : daysOfWeek;

    for (const n of days) {
      set.add(n);
    }
  }

  expr.include = anyDay && anyDaysOfWeek ? expandFieldItem('*', 1, 31) : Array.from(include).sort(sortAsc);
  expr.nearestWeekdays = Array.from(nearestWeekdays).sort(sortAsc);
  expr.daysOfWeek = Array.from(daysOfWeek).sort(sortAsc);
  expr.lastDaysOfWeek = Array.from(lastDaysOfWeek).sort(sortAsc);
  return expr;
}

function monthsParser(field) {
  const allowed = new Set();
  const normalisedField = field.replace(monthReplacementRegex, match => {
    return monthReplacements.indexOf(match) + 1 + '';
  });

  for (const item of normalisedField.split(',')) {
    for (const n of expandFieldItem(item, 1, 12, true)) {
      allowed.add(n);
    }
  }

  return Array.from(allowed).sort(sortAsc);
}

function yearsParser(field) {
  const allowed = new Set();

  for (const item of field.split(',')) {
    for (const n of expandFieldItem(item, 1970, 2099)) {
      allowed.add(n);
    }
  }

  return Array.from(allowed).sort(sortAsc);
}

class CronosDate {
  constructor(year) {
    let month = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    let day = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    let hour = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    let minute = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    let second = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    this.year = year;
    this.month = month;
    this.day = day;
    this.hour = hour;
    this.minute = minute;
    this.second = second;
  }

  static fromDate(date, timezone) {
    if (!timezone) {
      return new CronosDate(date.getFullYear(), date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds());
    }

    return timezone['nativeDateToCronosDate'](date);
  }

  toDate(timezone) {
    if (!timezone) {
      return new Date(this.year, this.month - 1, this.day, this.hour, this.minute, this.second);
    }

    return timezone['cronosDateToNativeDate'](this);
  }

  static fromUTCTimestamp(timestamp) {
    const date = new Date(timestamp);
    return new CronosDate(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
  }

  toUTCTimestamp() {
    return Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second);
  }

  copyWith() {
    let {
      year = this.year,
      month = this.month,
      day = this.day,
      hour = this.hour,
      minute = this.minute,
      second = this.second
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return new CronosDate(year, month, day, hour, minute, second);
  }

} // Adapted from Intl.DateTimeFormat timezone handling in https://github.com/moment/luxon

const ZoneCache = new Map();
class CronosTimezone {
  constructor(IANANameOrOffset) {
    if (typeof IANANameOrOffset === 'number') {
      if (IANANameOrOffset > 840 || IANANameOrOffset < -840) throw new Error('Invalid offset');
      this.fixedOffset = IANANameOrOffset;
      return this;
    }

    const offsetMatch = IANANameOrOffset.match(/^([+-]?)(0[1-9]|1[0-4])(?::?([0-5][0-9]))?$/);

    if (offsetMatch) {
      this.fixedOffset = (offsetMatch[1] === '-' ? -1 : 1) * (parseInt(offsetMatch[2], 10) * 60 + (parseInt(offsetMatch[3], 10) || 0));
      return this;
    }

    if (ZoneCache.has(IANANameOrOffset)) {
      return ZoneCache.get(IANANameOrOffset);
    }

    try {
      this.dateTimeFormat = new Intl.DateTimeFormat("en-US", {
        hour12: false,
        timeZone: IANANameOrOffset,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      });
    } catch (err) {
      throw new Error('Invalid IANA name or offset');
    }

    this.zoneName = IANANameOrOffset;
    const currentYear = new Date().getUTCFullYear();
    this.winterOffset = this.offset(Date.UTC(currentYear, 0, 1));
    this.summerOffset = this.offset(Date.UTC(currentYear, 5, 1));
    ZoneCache.set(IANANameOrOffset, this);
  }

  toString() {
    if (this.fixedOffset) {
      const absOffset = Math.abs(this.fixedOffset);
      return [this.fixedOffset < 0 ? '-' : '+', Math.floor(absOffset / 60).toString().padStart(2, '0'), (absOffset % 60).toString().padStart(2, '0')].join('');
    }

    return this.zoneName;
  }

  offset(ts) {
    if (!this.dateTimeFormat) return this.fixedOffset || 0;
    const date = new Date(ts);
    const {
      year,
      month,
      day,
      hour,
      minute,
      second
    } = this.nativeDateToCronosDate(date);
    const asUTC = Date.UTC(year, month - 1, day, hour, minute, second),
          asTS = ts - ts % 1000;
    return (asUTC - asTS) / 60000;
  }

  nativeDateToCronosDate(date) {
    if (!this.dateTimeFormat) {
      return CronosDate['fromUTCTimestamp'](date.getTime() + (this.fixedOffset || 0) * 60000);
    }

    return this.dateTimeFormat.formatToParts ? partsOffset(this.dateTimeFormat, date) : hackyOffset(this.dateTimeFormat, date);
  }

  cronosDateToNativeDate(date) {
    if (!this.dateTimeFormat) {
      return new Date(date['toUTCTimestamp']() - (this.fixedOffset || 0) * 60000);
    }

    const provisionalOffset = (date.month > 3 || date.month < 11 ? this.summerOffset : this.winterOffset) || 0;
    const UTCTimestamp = date['toUTCTimestamp'](); // Find the right offset a given local time.
    // Our UTC time is just a guess because our offset is just a guess

    let utcGuess = UTCTimestamp - provisionalOffset * 60000; // Test whether the zone matches the offset for this ts

    const o2 = this.offset(utcGuess); // If so, offset didn't change and we're done

    if (provisionalOffset === o2) return new Date(utcGuess); // If not, change the ts by the difference in the offset

    utcGuess -= (o2 - provisionalOffset) * 60000; // If that gives us the local time we want, we're done

    const o3 = this.offset(utcGuess);
    if (o2 === o3) return new Date(utcGuess); // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time

    return new Date(UTCTimestamp - Math.min(o2, o3) * 60000);
  }

}

function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""),
        parsed = formatted.match(/(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/),
        [, month, day, year, hour, minute, second] = (parsed || []).map(n => parseInt(n, 10));
  return new CronosDate(year, month, day, hour, minute, second);
}

function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  return new CronosDate(parseInt(formatted[4].value, 10), parseInt(formatted[0].value, 10), parseInt(formatted[2].value, 10), parseInt(formatted[6].value, 10), parseInt(formatted[8].value, 10), parseInt(formatted[10].value, 10));
}

const hourinms = 60 * 60 * 1000;

const findFirstFrom = (from, list) => list.findIndex(n => n >= from);

class CronosExpression {
  constructor(cronString, seconds, minutes, hours, days, months, years) {
    this.cronString = cronString;
    this.seconds = seconds;
    this.minutes = minutes;
    this.hours = hours;
    this.days = days;
    this.months = months;
    this.years = years;
    this.skipRepeatedHour = true;
    this.missingHour = 'insert';
  }

  static parse(cronstring) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    const expr = _parse(cronstring);

    expr.timezone = options.timezone instanceof CronosTimezone ? options.timezone : options.timezone !== undefined ? new CronosTimezone(options.timezone) : undefined;
    expr.skipRepeatedHour = options.skipRepeatedHour !== undefined ? options.skipRepeatedHour : expr.skipRepeatedHour;
    expr.missingHour = options.missingHour || expr.missingHour;
    return expr;
  }

  toString() {
    const showTzOpts = !this.timezone || this.timezone.zoneName;
    const timezone = Object.entries({
      tz: this.timezone && this.timezone.toString() || 'Local',
      skipRepeatedHour: showTzOpts && this.skipRepeatedHour.toString(),
      missingHour: showTzOpts && this.missingHour
    }).map((_ref) => {
      let [key, val] = _ref;
      return val && key + ': ' + val;
    }).filter(s => s).join(', ');
    return "".concat(this.cronString, " (").concat(timezone, ")");
  }

  nextDate() {
    let afterDate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
    const fromCronosDate = CronosDate.fromDate(afterDate, this.timezone);

    if (this.timezone && this.timezone.fixedOffset !== undefined) {
      return this._next(fromCronosDate).date;
    }

    const fromTimestamp = afterDate.getTime(),
          fromLocalTimestamp = fromCronosDate['toUTCTimestamp'](),
          prevHourLocalTimestamp = CronosDate.fromDate(new Date(fromTimestamp - hourinms), this.timezone)['toUTCTimestamp'](),
          nextHourLocalTimestamp = CronosDate.fromDate(new Date(fromTimestamp + hourinms), this.timezone)['toUTCTimestamp'](),
          nextHourRepeated = nextHourLocalTimestamp - fromLocalTimestamp === 0,
          thisHourRepeated = fromLocalTimestamp - prevHourLocalTimestamp === 0,
          thisHourMissing = fromLocalTimestamp - prevHourLocalTimestamp === hourinms * 2;

    if (this.skipRepeatedHour && thisHourRepeated) {
      return this._next(fromCronosDate.copyWith({
        minute: 59,
        second: 60
      }), false).date;
    }

    if (this.missingHour === 'offset' && thisHourMissing) {
      const nextDate = this._next(fromCronosDate.copyWith({
        hour: fromCronosDate.hour - 1
      })).date;

      if (!nextDate || nextDate.getTime() > fromTimestamp) return nextDate;
    }

    let {
      date: nextDate,
      cronosDate: nextCronosDate
    } = this._next(fromCronosDate);

    if (this.missingHour !== 'offset' && nextCronosDate && nextDate) {
      const nextDateNextHourTimestamp = nextCronosDate.copyWith({
        hour: nextCronosDate.hour + 1
      }).toDate(this.timezone).getTime();

      if (nextDateNextHourTimestamp === nextDate.getTime()) {
        if (this.missingHour === 'insert') {
          return nextCronosDate.copyWith({
            minute: 0,
            second: 0
          }).toDate(this.timezone);
        } // this.missingHour === 'skip'


        return this._next(nextCronosDate.copyWith({
          minute: 59,
          second: 59
        })).date;
      }
    }

    if (!this.skipRepeatedHour) {
      if (nextHourRepeated && (!nextDate || nextDate.getTime() > fromTimestamp + hourinms)) {
        nextDate = this._next(fromCronosDate.copyWith({
          minute: 0,
          second: 0
        }), false).date;
      }

      if (nextDate && nextDate < afterDate) {
        nextDate = new Date(nextDate.getTime() + hourinms);
      }
    }

    return nextDate;
  }

  _next(date) {
    let after = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    const nextDate = this._nextYear(after ? date.copyWith({
      second: date.second + 1
    }) : date);

    return {
      cronosDate: nextDate,
      date: nextDate ? nextDate.toDate(this.timezone) : null
    };
  }

  nextNDates() {
    let afterDate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
    let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
    const dates = [];
    let lastDate = afterDate;

    for (let i = 0; i < n; i++) {
      const date = this.nextDate(lastDate);
      if (!date) break;
      lastDate = date;
      dates.push(date);
    }

    return dates;
  }

  _nextYear(fromDate) {
    let nextYearIndex = findFirstFrom(fromDate.year, this.years);
    let nextDate = null;

    while (!nextDate) {
      const nextYear = this.years[nextYearIndex];
      if (nextYear === undefined) return null;
      nextDate = this._nextMonth(nextYear === fromDate.year ? fromDate : new CronosDate(nextYear));
      nextYearIndex++;
    }

    return nextDate;
  }

  _nextMonth(fromDate) {
    let nextMonthIndex = findFirstFrom(fromDate.month, this.months);
    let nextDate = null;

    while (!nextDate) {
      const nextMonth = this.months[nextMonthIndex];
      if (nextMonth === undefined) return null;
      nextDate = this._nextDay(nextMonth === fromDate.month ? fromDate : new CronosDate(fromDate.year, nextMonth));
      nextMonthIndex++;
    }

    return nextDate;
  }

  _nextDay(fromDate) {
    const days = this._resolveDays(fromDate.year, fromDate.month);

    let nextDayIndex = findFirstFrom(fromDate.day, days);
    let nextDate = null;

    while (!nextDate) {
      const nextDay = days[nextDayIndex];
      if (nextDay === undefined) return null;
      nextDate = this._nextHour(nextDay === fromDate.day ? fromDate : new CronosDate(fromDate.year, fromDate.month, nextDay));
      nextDayIndex++;
    }

    return nextDate;
  }

  _resolveDays(year, month) {
    const days = new Set(this.days.include);
    const lastDateOfMonth = new Date(year, month, 0).getDate();
    const firstDayOfWeek = new Date(year, month - 1, 1).getDay();

    const getNearestWeekday = day => {
      if (day > lastDateOfMonth) day = lastDateOfMonth;
      const dayOfWeek = (day + firstDayOfWeek - 1) % 7;
      let weekday = day + (dayOfWeek === 0 ? 1 : dayOfWeek === 6 ? -1 : 0);
      return weekday + (weekday < 1 ? 3 : weekday > lastDateOfMonth ? -3 : 0);
    };

    if (this.days.last) {
      days.add(lastDateOfMonth);
    }

    if (this.days.lastWeekday) {
      days.add(getNearestWeekday(lastDateOfMonth));
    }

    for (const day of this.days.nearestWeekdays) {
      days.add(getNearestWeekday(day));
    }

    if (this.days.daysOfWeek.length || this.days.lastDaysOfWeek.length || this.days.nthDaysOfWeek.length) {
      const daysOfWeek = Array(7).fill(0).map(() => []);

      for (let day = 1; day < 36; day++) {
        daysOfWeek[(day + firstDayOfWeek - 1) % 7].push(day);
      }

      for (const dayOfWeek of this.days.daysOfWeek) {
        for (const day of daysOfWeek[dayOfWeek]) {
          days.add(day);
        }
      }

      for (const dayOfWeek of this.days.lastDaysOfWeek) {
        for (let i = daysOfWeek[dayOfWeek].length - 1; i >= 0; i--) {
          if (daysOfWeek[dayOfWeek][i] <= lastDateOfMonth) {
            days.add(daysOfWeek[dayOfWeek][i]);
            break;
          }
        }
      }

      for (const [dayOfWeek, nthOfMonth] of this.days.nthDaysOfWeek) {
        days.add(daysOfWeek[dayOfWeek][nthOfMonth - 1]);
      }
    }

    return Array.from(days).filter(day => day <= lastDateOfMonth).sort(sortAsc);
  }

  _nextHour(fromDate) {
    let nextHourIndex = findFirstFrom(fromDate.hour, this.hours);
    let nextDate = null;

    while (!nextDate) {
      const nextHour = this.hours[nextHourIndex];
      if (nextHour === undefined) return null;
      nextDate = this._nextMinute(nextHour === fromDate.hour ? fromDate : new CronosDate(fromDate.year, fromDate.month, fromDate.day, nextHour));
      nextHourIndex++;
    }

    return nextDate;
  }

  _nextMinute(fromDate) {
    let nextMinuteIndex = findFirstFrom(fromDate.minute, this.minutes);
    let nextDate = null;

    while (!nextDate) {
      const nextMinute = this.minutes[nextMinuteIndex];
      if (nextMinute === undefined) return null;
      nextDate = this._nextSecond(nextMinute === fromDate.minute ? fromDate : new CronosDate(fromDate.year, fromDate.month, fromDate.day, fromDate.hour, nextMinute));
      nextMinuteIndex++;
    }

    return nextDate;
  }

  _nextSecond(fromDate) {
    const nextSecondIndex = findFirstFrom(fromDate.second, this.seconds),
          nextSecond = this.seconds[nextSecondIndex];
    if (nextSecond === undefined) return null;
    return fromDate.copyWith({
      second: nextSecond
    });
  }

}

const maxTimeout = Math.pow(2, 31) - 1;
const scheduledTasks = [];
let runningTimer = null;

function addTask(task) {
  if (task['_timestamp']) {
    const insertIndex = scheduledTasks.findIndex(t => (t['_timestamp'] || 0) < (task['_timestamp'] || 0));
    if (insertIndex >= 0) scheduledTasks.splice(insertIndex, 0, task);else scheduledTasks.push(task);
  }
}

function removeTask(task) {
  const removeIndex = scheduledTasks.indexOf(task);
  if (removeIndex >= 0) scheduledTasks.splice(removeIndex, 1);

  if (scheduledTasks.length === 0 && runningTimer) {
    clearTimeout(runningTimer);
    runningTimer = null;
  }
}

function runScheduledTasks() {
  if (runningTimer) clearTimeout(runningTimer);
  const now = Date.now();
  const removeIndex = scheduledTasks.findIndex(task => (task['_timestamp'] || 0) <= now);
  const tasksToRun = removeIndex >= 0 ? scheduledTasks.splice(removeIndex) : [];

  for (let task of tasksToRun) {
    task['_runTask']();

    if (task.isRunning) {
      task['_updateTimestamp']();
      addTask(task);
    }
  }

  const nextTask = scheduledTasks[scheduledTasks.length - 1];

  if (nextTask) {
    runningTimer = setTimeout(runScheduledTasks, Math.min((nextTask['_timestamp'] || 0) - Date.now(), maxTimeout));
  } else runningTimer = null;
}

class DateArraySequence {
  constructor(dateLikes) {
    this._dates = dateLikes.map(dateLike => {
      const date = new Date(dateLike);
      if (isNaN(date.getTime())) throw new Error('Invalid date');
      return date;
    }).sort((a, b) => a.getTime() - b.getTime());
  }

  nextDate(afterDate) {
    const nextIndex = this._dates.findIndex(d => d > afterDate);

    return nextIndex === -1 ? null : this._dates[nextIndex];
  }

}

class CronosTask {
  constructor(sequenceOrDates) {
    this._listeners = {
      'started': new Set(),
      'stopped': new Set(),
      'run': new Set(),
      'ended': new Set()
    };
    if (Array.isArray(sequenceOrDates)) this._sequence = new DateArraySequence(sequenceOrDates);else if (typeof sequenceOrDates === 'string' || typeof sequenceOrDates === 'number' || sequenceOrDates instanceof Date) this._sequence = new DateArraySequence([sequenceOrDates]);else this._sequence = sequenceOrDates;
  }

  start() {
    this._updateTimestamp();

    addTask(this);
    runScheduledTasks();
    if (this._timestamp) this._emit('started');
    return this;
  }

  stop() {
    this._timestamp = undefined;
    removeTask(this);

    this._emit('stopped');

    return this;
  }

  get nextRun() {
    return this._timestamp ? new Date(this._timestamp) : undefined;
  }

  get isRunning() {
    return !!this._timestamp;
  }

  _runTask() {
    this._emit('run', this._timestamp);
  }

  _updateTimestamp() {
    const nextDate = this._sequence.nextDate(this._timestamp ? new Date(this._timestamp) : new Date());

    let timestamp = nextDate ? nextDate.getTime() : undefined;
    if (this._timestamp && timestamp && timestamp < this._timestamp + 1000) timestamp = this._timestamp + 1000;
    this._timestamp = timestamp;
    if (!this._timestamp) this._emit('ended');
  }

  on(event, listener) {
    this._listeners[event].add(listener);

    return this;
  }

  off(event, listener) {
    this._listeners[event].delete(listener);

    return this;
  }

  _emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    this._listeners[event].forEach(listener => {
      listener.call(this, ...args);
    });
  }

}

function scheduleTask(cronString, task, options) {
  const expression = CronosExpression.parse(cronString, options);
  return new CronosTask(expression).on('run', task).start();
}
function validate(cronString) {
  try {
    CronosExpression.parse(cronString);
  } catch (_unused) {
    return false;
  }

  return true;
}

export { CronosExpression, CronosTask, CronosTimezone, scheduleTask, validate };
